# app.py
import streamlit as st
import os
import json
import config
from pdf_utils import process_pdf
from chatbot import initialize_chat, get_questions, generate_answer
from datetime import datetime


# Configuration
GEMINI_API_KEY = config.GOOGLE_API_KEY
OUTPUT_TEXT_FILE = "extracted_text.txt"
IMAGES_FOLDER = "extracted_images"

# Session state initialization
if 'processed' not in st.session_state:
    st.session_state.update({
        'processed': False,
        'chat_initialized': False,
        'current_question': 0,
        'questions': get_questions(),
        'answers': {},
        'feedback_history': {}
    })

st.title("Tech Transfer ChatBot")

# 1. PDF Processing Section (unchanged)
uploaded_file = st.file_uploader("Upload Research PDF", type=["pdf"])
if uploaded_file and not st.session_state.processed:
    with st.spinner("Processing PDF..."):
        with open("temp.pdf", "wb") as f:
            f.write(uploaded_file.getbuffer())
        
        process_pdf("temp.pdf", OUTPUT_TEXT_FILE, IMAGES_FOLDER, GEMINI_API_KEY)
        st.session_state.pdf_text = open(OUTPUT_TEXT_FILE).read()
        st.session_state.processed = True
        st.session_state.chat = initialize_chat(GEMINI_API_KEY)
        
    st.success("PDF processed successfully!")
    st.download_button(
        label="Download Extracted Text",
        data=open(OUTPUT_TEXT_FILE, "rb").read(),
        file_name="extracted_text.txt",
        mime="text/plain"
    )

import asyncio
from playwright.async_api import async_playwright

async def html_to_pdf(html_content, output_path):
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()
        await page.set_content(html_content)
        await page.pdf(path=output_path)
        await browser.close()

# 2. Q&A Section (modified for PDF and form submission)
if st.session_state.processed:
    st.divider()
    st.header("Your Research Analysis!")
    
        # Update the PDF generation section with proper Unicode handling
    # Replace the existing PDF generation section with this:

    if st.session_state.current_question >= len(st.session_state.questions):
        st.header("✅ Analysis Complete!")
        st.markdown("### Final Report")
        
        # Generate HTML Report
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Tech Transfer Research Analysis Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { text-align: center; border-bottom: 2px solid #333; margin-bottom: 30px; }
                .section { margin-bottom: 25px; }
                .question { font-weight: bold; color: #2c3e50; font-size: 1.1em; }
                .answer { margin: 10px 0 20px 20px; color: #34495e; line-height: 1.6; }
                .footer { text-align: center; margin-top: 40px; color: #666; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Tech Transfer Research Analysis Report</h1>
                <p>Generated by Tech Transfer ChatBot</p>
            </div>
        """
        
        # Add questions and answers
        for idx, q_data in enumerate(st.session_state.questions):
            param = q_data["param"]
            question = q_data["question"]
            answer = st.session_state.answers[param]['answer']
            
            html_content += f"""
            <div class="section">
                <div class="question">Question {idx+1}: {question}</div>
                <div class="answer">{answer.replace('\n', '<br>')}</div>
            </div>
            """
        
        # Add footer
        html_content += """
            <div class="footer">
                <p>Report generated on {datetime}</p>
            </div>
        </body>
        </html>
        """.format(datetime=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        
        # Save HTML file
        html_file = "research_analysis.html"
        with open(html_file, "w", encoding="utf-8") as f:
            f.write(html_content)
        
        try:
            
            pdf_file = "research_analysis.pdf"
            # You can use pdfkit.from_string(html_content, pdf_file) as an alternative.
            #HTML(string=html_content).write_pdf(pdf_file)
            asyncio.run(html_to_pdf(html_content, pdf_file))
        except Exception as e:
            st.error("PDF conversion failed.")
            pdf_file = None

        # Download buttons
        col1, col2, col3 = st.columns(3)
        with col1:
            with open(html_file, "rb") as f:
                st.download_button(
                    label="Download Full Report (HTML)",
                    data=f,
                    file_name=html_file,
                    mime="text/html",
                    help="Open in browser and use 'Print > Save as PDF' for PDF version"
                )
        with col2:
            if pdf_file and os.path.exists(pdf_file):
                with open(pdf_file, "rb") as f:
                    st.download_button(
                        label="Download Full Report (PDF)",
                        data=f,
                        file_name=pdf_file,
                        mime="application/pdf"
                    )
            else:
                st.write("PDF not available.")
        with col3:
            if st.button("Upload Another PDF"):
                # Clear session state
                for key in list(st.session_state.keys()):
                    del st.session_state[key]
                st.rerun()


    else:
        current_q_data = st.session_state.questions[st.session_state.current_question]
        param = current_q_data["param"]
        
        if param not in st.session_state.answers:
            st.session_state.answers[param] = {'answer': '', 'versions': []}
            st.session_state.feedback_history[param] = []
        
        st.subheader(f"Question {st.session_state.current_question + 1}/{len(st.session_state.questions)}")
        st.markdown(f"**Parameter:** {param}")
        st.markdown(f"**Question:** {current_q_data['question']}")
        
        if not st.session_state.answers[param]['versions']:
            with st.spinner("Generating initial answer..."):
                response = generate_answer(
                    st.session_state.chat,
                    current_q_data["question"],
                    st.session_state.pdf_text
                )
                st.session_state.answers[param]['versions'].append(response)
                st.session_state.answers[param]['answer'] = response
        
        st.markdown("### Current Answer")
        st.write(st.session_state.answers[param]['answer'])
        
        # Modified feedback section with form
        with st.form(key='feedback_form'):
            st.markdown("### Refine the Answer")
            # Create unique key for each question's feedback
            feedback_key = f"feedback_{param}"
            
            # Initialize feedback if not exists
            if feedback_key not in st.session_state:
                st.session_state[feedback_key] = ""
            feedback = st.text_area("Provide feedback for refinement (press Enter to submit)")
            submitted = st.form_submit_button("Refine Answer")
            
            if submitted:
                if feedback.strip():
                    st.session_state.feedback_history[param].append(feedback)
                    st.session_state[feedback_key] = ""
                    
                    with st.spinner("Refining answer..."):
                        prompt = (
                            f"{current_q_data['question']}\n\n"
                            f"Previous answer: {st.session_state.answers[param]['answer']}\n"
                            f"Feedback: {feedback}\n"
                        )
                        refined_answer = generate_answer(
                            st.session_state.chat,
                            prompt,
                            st.session_state.pdf_text
                        )
                        st.session_state.answers[param]['versions'].append(refined_answer)
                        st.session_state.answers[param]['answer'] = refined_answer
                    st.session_state[feedback_key] = ""
                    st.rerun()
                else:
                    st.warning("No feedback provided. Please enter feedback or skip refinement.")

        if st.session_state.feedback_history[param]:
            st.markdown("#### Refinement History")
            for i, fb in enumerate(st.session_state.feedback_history[param], 1):
                st.write(f"**{i}.** {fb}")
        
        st.divider()
        col1, col2 = st.columns(2)
        with col1:
            if st.button("← Previous Question", disabled=(st.session_state.current_question == 0)):
                st.session_state.current_question -= 1
                st.rerun()
                
        with col2:
            if st.button("Next Question →"):
                st.session_state.current_question += 1
                st.rerun()


